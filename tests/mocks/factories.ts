/**
 * Mock Factories for Testing
 * 
 * Provides factory functions for creating consistent test mocks for v0.dev components,
 * including V0 client, logger, and configuration objects.
 */

import { V0ClientWrapper } from '../../src/api/v0/client.js';
import { Logger } from '../../src/logging/types.js';
import { ServerConfig } from '../../src/types/config-types.js';
import { Either, right, left } from '../../src/utils/either.js';

// Mock V0 Client Factory
export interface MockV0ClientOptions {
  apiKey?: string;
  shouldFailGenerate?: boolean;
  shouldFailIterate?: boolean;
  generateDelay?: number;
  iterateDelay?: number;
  customResponses?: {
    generate?: any;
    iterate?: any;
    user?: any;
    projects?: any;
    chats?: any;
  };
}

export const createMockV0Client = (options: MockV0ClientOptions = {}): V0ClientWrapper => {
  const {
    apiKey = 'test-api-key',
    shouldFailGenerate = false,
    shouldFailIterate = false,
    generateDelay = 0,
    iterateDelay = 0,
    customResponses = {}
  } = options;

  const defaultChatResponse = {
    id: 'test-chat-123',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    title: 'Test Component',
    latestVersion: {
      id: 'version-456', 
      createdAt: new Date().toISOString(),
      files: [
        {
          name: 'component.tsx',
          content: `import React from 'react';

export default function TestComponent() {
  return (
    <div className="p-4 bg-blue-100 rounded">
      <h1 className="text-xl font-bold">Test Component</h1>
      <p>This is a test component generated by the mock.</p>
    </div>
  );
}`,
          language: 'tsx' as const,
          path: 'component.tsx'
        },
        {
          name: 'styles.css',
          content: `.test-component {
  padding: 1rem;
  background-color: #dbeafe;
  border-radius: 0.5rem;
}

.test-component h1 {
  font-size: 1.25rem;
  font-weight: bold;
}`,
          language: 'css' as const,
          path: 'styles.css'
        }
      ]
    }
  };

  const defaultUserResponse = {
    id: 'user-123',
    email: 'test@example.com',
    name: 'Test User',
    createdAt: new Date().toISOString()
  };

  // Create mock v0 SDK client
  const mockSdkClient = {
    // Chat methods
    chats: {
      create: jest.fn().mockImplementation(async ({ description }) => {
        await new Promise(resolve => setTimeout(resolve, generateDelay));
        
        if (shouldFailGenerate) {
          throw new Error('Mock generate failure');
        }
        
        return customResponses.generate || {
          ...defaultChatResponse,
          title: description.substring(0, 50)
        };
      }),
      
      getById: jest.fn().mockImplementation(async ({ chatId }) => {
        return customResponses.iterate || {
          ...defaultChatResponse,
          id: chatId
        };
      }),

      sendMessage: jest.fn().mockImplementation(async ({ chatId, message }) => {
        await new Promise(resolve => setTimeout(resolve, iterateDelay));
        
        if (shouldFailIterate) {
          throw new Error('Mock iterate failure');
        }
        
        return customResponses.iterate || {
          ...defaultChatResponse,
          id: chatId,
          title: `Updated: ${message.substring(0, 30)}`
        };
      }),

      list: jest.fn().mockResolvedValue([defaultChatResponse]),
      delete: jest.fn().mockResolvedValue({ success: true })
    },

    // User methods
    user: {
      get: jest.fn().mockResolvedValue(customResponses.user || defaultUserResponse)
    },

    // Project methods
    projects: {
      create: jest.fn().mockResolvedValue({
        id: 'project-123',
        name: 'Test Project',
        createdAt: new Date().toISOString()
      }),
      list: jest.fn().mockResolvedValue([]),
      getById: jest.fn().mockResolvedValue(null),
      update: jest.fn().mockResolvedValue({ success: true }),
      delete: jest.fn().mockResolvedValue({ success: true }),
      assign: jest.fn().mockResolvedValue({ success: true })
    },

    // Deployment methods
    deployments: {
      create: jest.fn().mockResolvedValue({
        id: 'deployment-123',
        url: 'https://test-deployment.vercel.app',
        status: 'ready',
        createdAt: new Date().toISOString()
      }),
      list: jest.fn().mockResolvedValue([]),
      getById: jest.fn().mockResolvedValue(null),
      delete: jest.fn().mockResolvedValue({ success: true }),
      getLogs: jest.fn().mockResolvedValue([])
    },

    // Webhook methods
    webhooks: {
      create: jest.fn().mockResolvedValue({
        id: 'webhook-123',
        url: 'https://example.com/webhook',
        events: ['chat.created'],
        active: true
      }),
      list: jest.fn().mockResolvedValue([]),
      getById: jest.fn().mockResolvedValue(null),
      update: jest.fn().mockResolvedValue({ success: true }),
      delete: jest.fn().mockResolvedValue({ success: true })
    }
  };

  return {
    client: mockSdkClient,
    config: {
      apiKey,
      timeout: 30000,
      maxRetries: 3
    },
    validatedAt: new Date()
  };
};

// Mock Logger Factory
export interface MockLoggerOptions {
  shouldLogToConsole?: boolean;
  logLevel?: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
  captureLogCalls?: boolean;
}

export const createMockLogger = (options: MockLoggerOptions = {}): Logger & { getCalls: () => any[] } => {
  const {
    shouldLogToConsole = false,
    logLevel = 'info',
    captureLogCalls = true
  } = options;

  const calls: any[] = [];

  const log = (level: string, message: string, data?: any) => {
    if (captureLogCalls) {
      calls.push({ level, message, data, timestamp: new Date() });
    }
    
    if (shouldLogToConsole) {
      console.log(`[${level.toUpperCase()}] ${message}`, data || '');
    }
  };

  return {
    trace: jest.fn().mockImplementation((message, data) => log('trace', message, data)),
    debug: jest.fn().mockImplementation((message, data) => log('debug', message, data)),
    info: jest.fn().mockImplementation((message, data) => log('info', message, data)),
    warn: jest.fn().mockImplementation((message, data) => log('warn', message, data)),
    error: jest.fn().mockImplementation((message, data) => log('error', message, data)),
    fatal: jest.fn().mockImplementation((message, data) => log('fatal', message, data)),

    child: jest.fn().mockReturnThis(),
    tag: jest.fn().mockReturnThis(),
    withCorrelationId: jest.fn().mockReturnThis(),
    time: jest.fn().mockReturnValue({ end: jest.fn() }),
    timeAsync: jest.fn().mockImplementation(async (fn) => fn()),

    getCalls: () => [...calls]
  };
};

// Mock Configuration Factory
export interface MockConfigOptions {
  apiKey?: string;
  name?: string;
  version?: string;
  verbose?: boolean;
  timeout?: number;
  maxMemoryMB?: number;
  customFields?: Partial<ServerConfig>;
}

export const createMockConfig = (options: MockConfigOptions = {}): ServerConfig => {
  const {
    apiKey = 'v1:test:mock-api-key-123',
    name = 'Test v0 MCP Server',
    version = '1.0.0-test',
    verbose = false,
    timeout = 30000,
    maxMemoryMB = 512,
    customFields = {}
  } = options;

  return {
    name,
    version,
    apiKey,
    verbose,
    timeout,
    maxMemoryMB,
    ...customFields
  };
};

// Mock Tool Registry Factory
export interface MockTool {
  name: string;
  description: string;
  inputSchema: any;
  execute: jest.MockedFunction<any>;
}

export interface MockToolRegistryOptions {
  tools?: MockTool[];
  shouldFailExecution?: boolean;
  executionDelay?: number;
}

export const createMockToolRegistry = (options: MockToolRegistryOptions = {}) => {
  const {
    tools = [],
    shouldFailExecution = false,
    executionDelay = 0
  } = options;

  const defaultTools: MockTool[] = [
    {
      name: 'generate_component',
      description: 'Generate a React component',
      inputSchema: {
        type: 'object',
        properties: {
          description: { type: 'string' },
          framework: { type: 'string', enum: ['react', 'vue', 'svelte'] },
          typescript: { type: 'boolean' },
          styling: { type: 'string', enum: ['tailwind', 'css', 'styled-components'] }
        },
        required: ['description']
      },
      execute: jest.fn().mockImplementation(async (args) => {
        await new Promise(resolve => setTimeout(resolve, executionDelay));
        
        if (shouldFailExecution) {
          throw new Error('Mock tool execution failure');
        }
        
        return {
          content: [
            {
              type: 'text',
              text: `Generated component: ${args.description}`
            }
          ]
        };
      })
    },
    {
      name: 'iterate_component',
      description: 'Iterate on an existing component',
      inputSchema: {
        type: 'object',
        properties: {
          chatId: { type: 'string' },
          changes: { type: 'string' }
        },
        required: ['chatId', 'changes']
      },
      execute: jest.fn().mockImplementation(async (args) => {
        await new Promise(resolve => setTimeout(resolve, executionDelay));
        
        if (shouldFailExecution) {
          throw new Error('Mock tool execution failure');
        }
        
        return {
          content: [
            {
              type: 'text', 
              text: `Iterated component ${args.chatId}: ${args.changes}`
            }
          ]
        };
      })
    }
  ];

  const allTools = [...defaultTools, ...tools];
  const toolMap = new Map(allTools.map(tool => [tool.name, tool]));

  return {
    tools: toolMap,
    listTools: jest.fn().mockReturnValue(Array.from(toolMap.values())),
    getTool: jest.fn().mockImplementation((name: string) => toolMap.get(name)),
    registerTool: jest.fn().mockImplementation((tool: MockTool) => {
      toolMap.set(tool.name, tool);
    }),
    executeTool: jest.fn().mockImplementation(async (name: string, args: any) => {
      const tool = toolMap.get(name);
      if (!tool) {
        throw new Error(`Tool not found: ${name}`);
      }
      return tool.execute(args);
    }),
    clear: jest.fn().mockImplementation(() => {
      toolMap.clear();
    }),
    size: jest.fn().mockReturnValue(toolMap.size)
  };
};

// Mock Performance Manager Factory
export interface MockPerformanceManagerOptions {
  defaultTimeout?: number;
  shouldTimeout?: boolean;
}

export const createMockPerformanceManager = (options: MockPerformanceManagerOptions = {}) => {
  const {
    defaultTimeout = 30000,
    shouldTimeout = false
  } = options;

  return {
    withTimeout: jest.fn().mockImplementation(async (fn, timeout = defaultTimeout) => {
      if (shouldTimeout) {
        throw new Error(`Operation timed out after ${timeout}ms`);
      }
      return fn();
    }),
    measureTime: jest.fn().mockImplementation(async (fn) => {
      const start = Date.now();
      const result = await fn();
      const duration = Date.now() - start;
      return { result, duration };
    }),
    getMetrics: jest.fn().mockReturnValue({
      totalRequests: 0,
      averageResponseTime: 0,
      errorRate: 0,
      uptime: Date.now()
    })
  };
};

// Mock Memory Monitor Factory
export const createMockMemoryMonitor = () => {
  return {
    getCurrentUsage: jest.fn().mockReturnValue({
      rss: 50 * 1024 * 1024, // 50MB
      heapTotal: 40 * 1024 * 1024, // 40MB
      heapUsed: 30 * 1024 * 1024, // 30MB
      external: 5 * 1024 * 1024 // 5MB
    }),
    isMemoryLimitExceeded: jest.fn().mockReturnValue(false),
    startMonitoring: jest.fn(),
    stopMonitoring: jest.fn(),
    getHistory: jest.fn().mockReturnValue([])
  };
};

// Mock Error Handler Factory
export const createMockErrorHandler = () => {
  return {
    handleError: jest.fn().mockImplementation((error, context) => {
      return {
        code: 'MOCK_ERROR',
        message: error.message || 'Mock error',
        data: {
          context,
          retryable: false,
          timestamp: new Date().toISOString()
        }
      };
    }),
    isRetryableError: jest.fn().mockReturnValue(false),
    formatError: jest.fn().mockImplementation((error) => error.message || 'Unknown error')
  };
};

// Mock Input Validator Factory
export const createMockInputValidator = () => {
  return {
    validateComponentDescription: jest.fn().mockImplementation((description: string) => {
      if (!description || description.length < 3) {
        return left('Description too short');
      }
      if (description.includes('<script>')) {
        return left('Dangerous content detected');
      }
      return right(description);
    }),
    validateChatId: jest.fn().mockImplementation((chatId: string) => {
      if (!chatId || chatId.length < 8) {
        return left('Invalid chat ID');
      }
      return right(chatId);
    }),
    validateStringLength: jest.fn().mockImplementation((str: string, min: number, max: number) => {
      if (str.length < min) return left('String too short');
      if (str.length > max) return left('String too long');
      return right(str);
    })
  };
};

// Factory for creating complete mock dependencies
export interface MockDependenciesOptions {
  v0Client?: MockV0ClientOptions;
  logger?: MockLoggerOptions;
  config?: MockConfigOptions;
  toolRegistry?: MockToolRegistryOptions;
  performanceManager?: MockPerformanceManagerOptions;
}

export const createMockDependencies = (options: MockDependenciesOptions = {}) => {
  return {
    logger: createMockLogger(options.logger),
    config: createMockConfig(options.config),
    v0Client: createMockV0Client(options.v0Client),
    toolRegistry: createMockToolRegistry(options.toolRegistry),
    performanceManager: createMockPerformanceManager(options.performanceManager),
    memoryMonitor: createMockMemoryMonitor(),
    errorHandler: createMockErrorHandler(),
    inputValidator: createMockInputValidator()
  };
};

// Utility functions for test scenarios
export const createSuccessScenario = () => createMockDependencies();

export const createFailureScenario = () => createMockDependencies({
  v0Client: {
    shouldFailGenerate: true,
    shouldFailIterate: true
  },
  toolRegistry: {
    shouldFailExecution: true
  },
  performanceManager: {
    shouldTimeout: true
  }
});

export const createSlowScenario = () => createMockDependencies({
  v0Client: {
    generateDelay: 1000,
    iterateDelay: 500
  },
  toolRegistry: {
    executionDelay: 200
  }
});

// Export types for TypeScript
export type MockDependencies = ReturnType<typeof createMockDependencies>;
export type MockLogger = ReturnType<typeof createMockLogger>;
export type MockToolRegistry = ReturnType<typeof createMockToolRegistry>;